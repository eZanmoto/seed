// Copyright 2023 Sean Kelleher. All rights reserved.
// Use of this source code is governed by an MIT
// licence that can be found in the LICENCE file.

use ast::*;
use lexer::LexError;
use lexer::Location as LexLocation;
use lexer::Token;

grammar;

pub Prog: Prog = {
    <stmts:Stmt*> => Prog::Body{stmts},
}

pub Stmt: Stmt = {
    // We require at least one statement in a block to avoid ambiguity between
    // empty blocks (`{}`) and empty objects (`{};`). Note that an empty object
    // must be followed by a semicolon when it's used as an expression
    // statement; however, because LALRPOP provides one lookahead token (LR(1)),
    // the decision of whether the production is an empty block or an empty
    // object needs to be made when the closing brace is encountered - the token
    // after can't be checked. We require at least one statement in a block as a
    // simple solution, rather than reworking the grammar to allow empty blocks.
    "{" <block:Stmt+> "}" => Stmt::Block{block},

    <expr:Expr> ";" => Stmt::Expr{expr},

    <lhs:Expr> ":=" <rhs:Expr> ";" => Stmt::Declare{lhs, rhs},
    <lhs:Expr> "=" <rhs:Expr> ";" => Stmt::Assign{lhs, rhs},
}

pub Expr: Expr = {
    <loc:@L> <expr:ExprPrecedence1> => (expr, loc),
}

// `ExprPrecedence1` defines the most loosely binding expressions. Each
// increasing precedence indicates a tighter binding.
pub ExprPrecedence1: RawExpr = {
    <loc:@L> <expr:ExprPrecedence1> "(" <args:ParamList> ")" =>
        RawExpr::Call{expr: Box::new((expr, loc)), args: args},

    <expr:ExprPrecedence2> => expr,
}

pub ParamList: Vec<Expr> = CommaSepList<Expr>;

CommaSepList<T>: Vec<T> = {
    <mut values:(<T> ",")*> <last:T?> => {
        if let Some(v) = last {
            values.push(v);
        }

        values
    }
}

pub ExprPrecedence2: RawExpr = {
    "null" => RawExpr::Null,
    "true" => RawExpr::Bool{b: true},
    "false" => RawExpr::Bool{b: false},

    <name:Ident> => RawExpr::Var{name},
    <n:IntLiteral> => RawExpr::Int{n},
    <s:StrLiteral> => RawExpr::Str{s},

    "[" <items:ExprList> "]" => RawExpr::List{items},
    "{" <props:PropList> "}" => RawExpr::Object{props},
}

pub ExprList: Vec<Expr> = {
    <mut values:(<Expr> ",")*> <last:Expr?> => {
        if let Some(v) = last {
            values.push(v);
        }

        values
    }
}

pub PropList: Vec<PropItem> = CommaSepList<PropItem>;

pub PropItem: PropItem = {
    <name:Expr> ":" <value:Expr> => PropItem::Pair{name, value},
}

Ident: String = {
    <s:"identifier"> => s,
};

IntLiteral: i64 = {
    <n:"int_literal"> => n,
};

StrLiteral: String = {
    <s:"str_literal"> => s,
};

extern {
    type Location = LexLocation;
    type Error = LexError;

    enum Token {
        "identifier" => Token::Ident(<String>),
        "int_literal" => Token::IntLiteral(<i64>),
        "str_literal" => Token::StrLiteral(<String>),

        "false" => Token::False,
        "null" => Token::Null,
        "true" => Token::True,

        "}" => Token::BraceClose,
        "{" => Token::BraceOpen,
        "]" => Token::BracketClose,
        "[" => Token::BracketOpen,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equals,
        ")" => Token::ParenClose,
        "(" => Token::ParenOpen,
        ";" => Token::Semicolon,

        ":=" => Token::ColonEquals,
    }
}
