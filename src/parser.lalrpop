// Copyright 2023 Sean Kelleher. All rights reserved.
// Use of this source code is governed by an MIT
// licence that can be found in the LICENCE file.

use ast::*;
use lexer::LexError;
use lexer::Location as LexLocation;
use lexer::Token;

grammar;

pub Prog: Prog = {
    <stmts:Stmt*> => Prog::Body{stmts},
}

pub Stmt: Stmt = {
    <expr:Expr> ";" => Stmt::Expr{expr},
}

pub Expr: Expr = {
    <loc:@L> <expr:ExprPrecedence1> => (expr, loc),
}

// `ExprPrecedence1` defines the most loosely binding expressions. Each
// increasing precedence indicates a tighter binding.
pub ExprPrecedence1: RawExpr = {
    <loc:@L> <expr:ExprPrecedence1> "(" <args:ParamList> ")" =>
        RawExpr::Call{expr: Box::new((expr, loc)), args: args},

    <expr:ExprPrecedence2> => expr,
}

pub ExprPrecedence2: RawExpr = {
    "null" => RawExpr::Null,

    <name:Ident> => RawExpr::Var{name},
    <s:StrLiteral> => RawExpr::Str{s},
}

pub ParamList: Vec<Expr> = CommaSepList<Expr>;

CommaSepList<T>: Vec<T> = {
    <mut values:(<T> ",")*> <last:T?> => {
        if let Some(v) = last {
            values.push(v);
        }

        values
    }
}

Ident: String = {
    <s:"identifier"> => s,
};

StrLiteral: String = {
    <s:"str_literal"> => s,
};

extern {
    type Location = LexLocation;
    type Error = LexError;

    enum Token {
        "identifier" => Token::Ident(<String>),
        "str_literal" => Token::StrLiteral(<String>),

        "null" => Token::Null,

        "," => Token::Comma,
        ")" => Token::ParenClose,
        "(" => Token::ParenOpen,
        ";" => Token::Semicolon,
    }
}
